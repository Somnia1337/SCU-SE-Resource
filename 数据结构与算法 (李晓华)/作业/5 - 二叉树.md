#### 5.2

节点总数 $n = n_0 + n_1 + n_2$，分支总数用前驱表示为 $b = n - 1$、用后继表示为 $b = n_1 + 2 n_2$，联立即得证。

#### 5.3

当 $n = 1$ 时，$I = 0$，$E = 2$，满足 $E = I + 2 n$。

如果结论对 $n$ 个节点成立，则也对 $n + 1$ 个节点成立。

设新增 1 个内节点后的树高为 $h$。

内路径长度为 $I(n + 1) = I(n) + h$

$\Rightarrow E(n + 1) = E(n) - h + 2(h + 1)$

$\Rightarrow E(n) = I(n) + 2 n$。

则 $E(n + 1) - h - 2 = I(n + 1) - h + 2 n$。

则 $E(n + 1) = I(n + 1) + 2 (n + 1)$，证毕。

#### 5.6

```java
public boolean search(TreeNode root, int k)
{
	return root != null && (root.val == k || search(root.left, k) || search(root.right, k));
}
```

#### 5.16

```text
        37
      /    \
    24      42
   /  \    /  \
  7   32  40  42
 /             \
2              120
 \
  5
```

#### 5.26

(b)

```text
    7
   / \
  4   6
 /   / \
2   1   3
```

#### 5.28

```text
                  209 
               /       \
             126       83
           /     \    /  \
          71     55  41  42
         /  \   /  \    /  \
        34  37 31  24  19  23
       /  \       /  \
      17  17     11  13
	 /  \
	10   7
   /  \
  5    5
 / \
2   3
```

`expected length in bits` = $3.234$。

#### 5.32

选项：

1) 有序链表
2) 无序链表
3) 二叉搜索树
4) 基于数组的有序列表
5) 基于数组的无序列表

(a) 选 4) 基于数组的有序列表

排除理由：1) 查询需要从头开始，查询复杂度过高；2) 无序，查询复杂度过高；3) 输入数据有序时退化，查询复杂度过高；5) 无序，查询复杂度过高

(b) 选 5) 二叉搜索树

排除理由：1) 为了维持有序，插入复杂度过高；2) 每次从头开始查询百万级别的数据，查询复杂度过高；4) 为了维持有序，插入复杂度过高；5) 每次需要查询百万级别的数据，查询复杂度过高

(c) 选 3) 二叉搜索树

排除理由：1) 查询需要从头开始，查询复杂度过高；2) 无序，查询复杂度过高；4) 为了维持有序，插入复杂度过高；5) 无序，查询复杂度过高

(d) 选 3) 二叉搜索树

排除理由：1) 查询需要从头开始，查询复杂度过高；2) 无序，查询复杂度过高；4) 为了维持有序，插入复杂度过高；5) 无序，查询复杂度过高